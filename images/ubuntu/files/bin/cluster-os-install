#!/bin/bash
# ClusterOS Bare-Metal Installer
# Installs ClusterOS image to a target disk with proper EFI boot support
set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $1"; }
log_ok() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check if running as root
if [ "$EUID" -ne 0 ]; then
    log_error "This script must be run as root"
    echo "Usage: sudo cluster-os-install /dev/sdX"
    exit 1
fi

# Check for target device argument
if [ -z "$1" ]; then
    log_error "No target device specified"
    echo ""
    echo "Usage: sudo cluster-os-install /dev/sdX"
    echo ""
    echo "Available block devices:"
    lsblk -d -o NAME,SIZE,TYPE,MODEL | grep disk
    exit 1
fi

TARGET_DEVICE="$1"

# Validate target device
if [ ! -b "$TARGET_DEVICE" ]; then
    log_error "Device $TARGET_DEVICE does not exist or is not a block device"
    exit 1
fi

# Check if device is mounted
if mount | grep -q "^$TARGET_DEVICE"; then
    log_error "Device $TARGET_DEVICE or its partitions are currently mounted"
    log_error "Please unmount them first"
    exit 1
fi

# Show device information
log_info "========================================="
log_info "ClusterOS Bare-Metal Installer"
log_info "========================================="
echo ""
log_info "Target device: $TARGET_DEVICE"
lsblk "$TARGET_DEVICE" 2>/dev/null || true
echo ""

# Confirm installation
log_warn "WARNING: This will ERASE ALL DATA on $TARGET_DEVICE"
echo ""
read -p "Type 'yes' to continue: " confirm
if [ "$confirm" != "yes" ]; then
    log_info "Installation cancelled"
    exit 0
fi

echo ""
log_info "Starting installation..."

# Find the installer image
INSTALLER_IMAGE=""
if [ -f "/usr/share/clusteros/installer.img.gz" ]; then
    log_info "Found embedded installer image"
    INSTALLER_IMAGE="/usr/share/clusteros/installer.img.gz"
elif [ -f "/run/live/medium/cluster-os.img" ]; then
    log_info "Found installer image on live medium"
    INSTALLER_IMAGE="/run/live/medium/cluster-os.img"
elif [ -f "/cluster-os.img" ]; then
    log_info "Found installer image in root"
    INSTALLER_IMAGE="/cluster-os.img"
else
    log_error "Could not find installer image"
    log_error "Expected locations:"
    log_error "  /usr/share/clusteros/installer.img.gz (embedded)"
    log_error "  /run/live/medium/cluster-os.img (live medium)"
    log_error "  /cluster-os.img (root)"
    exit 1
fi

# Write image to disk
log_info "Writing ClusterOS image to $TARGET_DEVICE..."
log_info "This may take several minutes..."

if [[ "$INSTALLER_IMAGE" == *.gz ]]; then
    log_info "Decompressing and writing image..."
    gunzip -c "$INSTALLER_IMAGE" | dd of="$TARGET_DEVICE" bs=4M status=progress conv=fsync
else
    log_info "Writing image..."
    dd if="$INSTALLER_IMAGE" of="$TARGET_DEVICE" bs=4M status=progress conv=fsync
fi

log_ok "Image written successfully"

# Ensure kernel picks up partition changes
log_info "Refreshing partition table..."
partprobe "$TARGET_DEVICE" 2>/dev/null || true
sleep 2

# Find the partitions
EFI_PART=""
ROOT_PART=""

# Try common partition naming schemes
for suffix in 1 2 3 p1 p2 p3; do
    if [ -b "${TARGET_DEVICE}${suffix}" ]; then
        # Check if it's an EFI partition (type code ef00 or FAT filesystem)
        if parted -s "$TARGET_DEVICE" print 2>/dev/null | grep -q "^ *${suffix#p}.*boot, esp"; then
            EFI_PART="${TARGET_DEVICE}${suffix}"
            log_info "Found EFI partition: $EFI_PART"
        elif [ -z "$ROOT_PART" ] && ! blkid "${TARGET_DEVICE}${suffix}" 2>/dev/null | grep -q "vfat"; then
            # Assume the first non-FAT partition is root
            ROOT_PART="${TARGET_DEVICE}${suffix}"
            log_info "Found root partition: $ROOT_PART"
        fi
    fi
done

# Fallback: just use first two partitions
if [ -z "$EFI_PART" ]; then
    if [ -b "${TARGET_DEVICE}1" ]; then
        EFI_PART="${TARGET_DEVICE}1"
    elif [ -b "${TARGET_DEVICE}p1" ]; then
        EFI_PART="${TARGET_DEVICE}p1"
    fi
fi

if [ -z "$ROOT_PART" ]; then
    if [ -b "${TARGET_DEVICE}2" ]; then
        ROOT_PART="${TARGET_DEVICE}2"
    elif [ -b "${TARGET_DEVICE}p2" ]; then
        ROOT_PART="${TARGET_DEVICE}p2"
    fi
fi

if [ -z "$ROOT_PART" ]; then
    log_error "Could not find root partition on $TARGET_DEVICE"
    log_error "Please check the device manually"
    exit 1
fi

# Install EFI bootloader
log_info "Installing EFI bootloader..."

# Create mount points
MOUNT_ROOT="/tmp/clusteros-install-root-$$"
MOUNT_EFI="/tmp/clusteros-install-efi-$$"
mkdir -p "$MOUNT_ROOT" "$MOUNT_EFI"

# Cleanup function
cleanup() {
    log_info "Cleaning up..."
    umount "$MOUNT_ROOT/boot/efi" 2>/dev/null || true
    umount "$MOUNT_ROOT/proc" 2>/dev/null || true
    umount "$MOUNT_ROOT/sys" 2>/dev/null || true
    umount "$MOUNT_ROOT/dev" 2>/dev/null || true
    umount "$MOUNT_ROOT" 2>/dev/null || true
    rmdir "$MOUNT_ROOT" "$MOUNT_EFI" 2>/dev/null || true
}
trap cleanup EXIT

# Mount root filesystem
log_info "Mounting root filesystem..."
if ! mount "$ROOT_PART" "$MOUNT_ROOT"; then
    log_error "Failed to mount root partition $ROOT_PART"
    exit 1
fi

# Mount EFI partition if it exists
if [ -n "$EFI_PART" ]; then
    log_info "Mounting EFI partition..."
    mkdir -p "$MOUNT_ROOT/boot/efi"
    if mount "$EFI_PART" "$MOUNT_ROOT/boot/efi" 2>/dev/null; then
        log_ok "EFI partition mounted"
    else
        log_warn "Could not mount EFI partition $EFI_PART"
    fi
fi

# Bind mount necessary filesystems for chroot
log_info "Preparing chroot environment..."
mount --bind /proc "$MOUNT_ROOT/proc"
mount --bind /sys "$MOUNT_ROOT/sys"
mount --bind /dev "$MOUNT_ROOT/dev"

# Install GRUB for EFI
log_info "Installing GRUB for EFI boot..."

# Check if EFI directory exists
if [ -d "$MOUNT_ROOT/boot/efi" ]; then
    # Install grub-efi if not present
    if ! chroot "$MOUNT_ROOT" which grub-install >/dev/null 2>&1; then
        log_info "Installing GRUB packages..."
        chroot "$MOUNT_ROOT" apt-get update >/dev/null 2>&1 || true
        chroot "$MOUNT_ROOT" apt-get install -y grub-efi-amd64 grub-efi-amd64-signed shim-signed >/dev/null 2>&1 || true
    fi
    
    # Install GRUB to EFI
    if chroot "$MOUNT_ROOT" grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=ubuntu --recheck --no-floppy 2>&1; then
        log_ok "GRUB EFI bootloader installed"
        
        # Update GRUB configuration
        log_info "Updating GRUB configuration..."
        chroot "$MOUNT_ROOT" update-grub 2>&1 | grep -v "^Sourcing" || true
        log_ok "GRUB configuration updated"
    else
        log_warn "GRUB EFI installation failed, trying legacy BIOS..."
        
        # Fallback to BIOS/MBR
        if chroot "$MOUNT_ROOT" grub-install --target=i386-pc "$TARGET_DEVICE" 2>&1; then
            log_ok "GRUB BIOS bootloader installed"
            chroot "$MOUNT_ROOT" update-grub 2>&1 | grep -v "^Sourcing" || true
        else
            log_error "Failed to install GRUB bootloader"
        fi
    fi
else
    log_warn "No EFI partition found, installing BIOS/MBR bootloader..."
    
    # Install GRUB for BIOS
    if ! chroot "$MOUNT_ROOT" which grub-install >/dev/null 2>&1; then
        log_info "Installing GRUB packages..."
        chroot "$MOUNT_ROOT" apt-get update >/dev/null 2>&1 || true
        chroot "$MOUNT_ROOT" apt-get install -y grub-pc >/dev/null 2>&1 || true
    fi
    
    if chroot "$MOUNT_ROOT" grub-install --target=i386-pc "$TARGET_DEVICE" 2>&1; then
        log_ok "GRUB BIOS bootloader installed"
        chroot "$MOUNT_ROOT" update-grub 2>&1 | grep -v "^Sourcing" || true
    else
        log_error "Failed to install GRUB bootloader"
    fi
fi

# Ensure fstab is correct
log_info "Configuring fstab..."
ROOT_UUID=$(blkid -s UUID -o value "$ROOT_PART")
if [ -n "$ROOT_UUID" ]; then
    # Update fstab with correct root UUID
    if grep -q "^UUID=" "$MOUNT_ROOT/etc/fstab"; then
        sed -i "s|^UUID=[^ ]*|UUID=$ROOT_UUID|" "$MOUNT_ROOT/etc/fstab"
    fi
fi

if [ -n "$EFI_PART" ]; then
    EFI_UUID=$(blkid -s UUID -o value "$EFI_PART")
    if [ -n "$EFI_UUID" ]; then
        # Add EFI partition to fstab if not present
        if ! grep -q "/boot/efi" "$MOUNT_ROOT/etc/fstab"; then
            echo "UUID=$EFI_UUID  /boot/efi  vfat  umask=0077  0  1" >> "$MOUNT_ROOT/etc/fstab"
        fi
    fi
fi

log_ok "fstab configured"

# Copy cluster key if available
if [ -f "/etc/clusteros/cluster.key" ]; then
    log_info "Copying cluster key..."
    mkdir -p "$MOUNT_ROOT/etc/clusteros"
    cp /etc/clusteros/cluster.key "$MOUNT_ROOT/etc/clusteros/"
    chmod 600 "$MOUNT_ROOT/etc/clusteros/cluster.key"
    log_ok "Cluster key copied"
fi

# Copy Tailscale credentials if available
if [ -f "/etc/clusteros/tailscale.env" ]; then
    log_info "Copying Tailscale credentials..."
    mkdir -p "$MOUNT_ROOT/etc/clusteros"
    cp /etc/clusteros/tailscale.env "$MOUNT_ROOT/etc/clusteros/"
    chmod 600 "$MOUNT_ROOT/etc/clusteros/tailscale.env"
    log_ok "Tailscale credentials copied"
fi

# Cleanup
cleanup
trap - EXIT

echo ""
log_ok "========================================="
log_ok "Installation complete!"
log_ok "========================================="
echo ""
log_info "You can now:"
log_info "  1. Remove the installation media"
log_info "  2. Reboot the system: sudo reboot"
log_info "  3. The system will boot into ClusterOS"
echo ""
log_info "On first boot, the node will:"
log_info "  - Connect to Tailscale automatically"
log_info "  - Join the cluster"
log_info "  - Start accepting workloads"
echo ""
